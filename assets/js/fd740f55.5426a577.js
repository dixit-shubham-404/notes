"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[1970],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),p=u(n),d=a,f=p["".concat(s,".").concat(d)]||p[d]||c[d]||l;return n?r.createElement(f,o(o({ref:t},m),{},{components:n})):r.createElement(f,o({ref:t},m))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[p]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8084:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const l={},o="Ownership in Rust",i={unversionedId:"Languages/RUST/Ownership",id:"Languages/RUST/Ownership",title:"Ownership in Rust",description:"Ownership is memory management system in rust. Other common memory management system include Garbage Collector and Manual Memory Management.",source:"@site/docs/Languages/RUST/Ownership.md",sourceDirName:"Languages/RUST",slug:"/Languages/RUST/Ownership",permalink:"/notes/docs/Languages/RUST/Ownership",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Languages/RUST/Ownership.md",tags:[],version:"current",frontMatter:{},sidebar:"language_sidebar",previous:{title:"Loops",permalink:"/notes/docs/Languages/RUST/Loops"},next:{title:"Structure",permalink:"/notes/docs/Languages/RUST/Struct"}},s={},u=[{value:"Ownership rules",id:"ownership-rules",level:2},{value:"Copy vs Move",id:"copy-vs-move",level:2},{value:"Ownership and function",id:"ownership-and-function",level:2},{value:"Rules of Refernces",id:"rules-of-refernces",level:2}],m={toc:u},p="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"ownership-in-rust"},"Ownership in Rust"),(0,a.kt)("p",null,"Ownership is memory management system in rust. Other common memory management system include Garbage Collector and Manual Memory Management."),(0,a.kt)("p",null,"Comparision between these are"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:"left"}),(0,a.kt)("th",{parentName:"tr",align:null},"Pros"),(0,a.kt)("th",{parentName:"tr",align:"right"},"Cons"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("strong",{parentName:"td"},"Garbage Collector")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Error free"),(0,a.kt)("li",null,"faster write time"))),(0,a.kt)("td",{parentName:"tr",align:"right"},(0,a.kt)("ul",null,(0,a.kt)("li",null,"No control over Memory"),(0,a.kt)("li",null,"Slower and unpredictable runtime performance"),(0,a.kt)("li",null,"Large Program Size")))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("strong",{parentName:"td"},"Manual Memory Management")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Control over Memory"),(0,a.kt)("li",null,"Faster runtime"),(0,a.kt)("li",null,"Small Program Size"))),(0,a.kt)("td",{parentName:"tr",align:"right"},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Error Prone"),(0,a.kt)("li",null,"Slower write time")))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"left"},(0,a.kt)("strong",{parentName:"td"},"OwnerShip Mode")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Control over Memory"),(0,a.kt)("li",null),"Error free",(0,a.kt)("li",null,"Faster runtime"),(0,a.kt)("li",null,"Small Program Size"))),(0,a.kt)("td",{parentName:"tr",align:"right"},(0,a.kt)("ul",null,(0,a.kt)("li",null,"Slower write time(Learning curve of borrow)")))))),(0,a.kt)("p",null,"When a program is executed it has two types of memory stacks and heap."),(0,a.kt)("br",null),"Stack memory is allacated at compile time it has stack frames for every function which inturn will have static variable stored. Stack memory is fixed size. The variables inside stack frame should have known fixed size. Life time of data is stack is till the execution of that function.",(0,a.kt)("br",null),(0,a.kt)("br",null),"Heap memory is allocated during runtime as demanded by the application. Life time if data is controlled by application. for dynamically allocated data stack store the pointer to heap memory instead of actual data.",(0,a.kt)("br",null),(0,a.kt)("br",null),"Accessing data at stack is faster than accessing data at heap as we have to go via stack to heap.",(0,a.kt)("h2",{id:"ownership-rules"},"Ownership rules"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Each value in rust has a variable thats called its owner."),(0,a.kt)("li",{parentName:"ul"},"There can only be one owner at a time."),(0,a.kt)("li",{parentName:"ul"},"When the owner get out of scope value will be dropped.")),(0,a.kt)("h2",{id:"copy-vs-move"},"Copy vs Move"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn main()\n{\n    let x = 5;\n    let y = x; // deep copy\n}\n")),(0,a.kt)("p",null,"In the above case rust will copy value 5 to y as x is in static memory, heap. This can be simply called cloning  "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main()\n{\n    let s1 = String::from("Hello");\n    let s2 = s1; // Move (not shallow copy)\n\n    println!("{}",s1); // this will throw error as s1 is move to s2.\n    // error :value borrowed here after move\n}\n')),(0,a.kt)("p",null,"In the above exapmle we move variable s1 to s2 completely hence removing existence of s1. If we just want to clone the values and do heavy operation of deep copy. Then we have to do it like this."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main()\n{\n    let s1 = String::from("Hello");\n    let s2 = s1.clone(); // deep copy\n\n    println!("{}",s1); \n\n}\n')),(0,a.kt)("h2",{id:"ownership-and-function"},"Ownership and function"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main()\n{\n    let s1 = String::from("hello");\n    takes_ownership(s1);\n    println("{}",s1); // this will give error : value borrowed here after move\n}\nfn takes_ownership(some_string :: String)\n{\n    println!("{}",some_string);\n}\n')),(0,a.kt)("p",null,"In the above example passing variable to a function as parameter is same as assigning it to a different variable, so passing variable to function will take its ownership.  ",(0,a.kt)("br",null)),(0,a.kt)("p",null,"The same rule doesn't apply on integer as they are copied not moved so this this will work fine."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main()\n{\n    let x = 1;\n    takes_ownership(x);\n    println("{}",x); // this will give error : value borrowed here after move\n}\nfn takes_ownership(x :: i32)\n{\n    println!("{}",x);\n}\n')),(0,a.kt)("p",null,"One way to avoid it is making a function which takes and gives back the ownership like this."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main()\n{\n    let s1 = String::from("Hello");\n    let s2 = takes_and_gives_back(s1);\n\n}\nfn takes_and_gives_back(some_string:String) -> String{\n    some_string\n}\n')),(0,a.kt)("br",null),"The error copying dynamic variables can be solved by passing refernce instead of variable.",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main()\n{\n    let s1 = String::from("hello");\n    takes_ownership(&s1);\n    println("{}",s1); // this print s1\n}\nfn takes_ownership(some_string :: &String)\n{\n    println!("{}",some_string);\n}\n')),(0,a.kt)("br",null),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Refernces are immutable by default so we can change it inside another function")),(0,a.kt)("br",null),"But if we still want to modify the value we can use mutable refernces. For that we have it make variable mutable too.",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main()\n{\n    let mut s1 = String::from("hello");\n    takes_ownership(&mut s1);\n    println("{}",s1); // this print s1 -> Hello World!\n}\nfn takes_ownership(some_string :: &mut String)\n{\n    some_string.push_str(" World!"); \n}\n')),(0,a.kt)("br",null),(0,a.kt)("p",null,"We cannot borrow refernce of mutable variable more than once in a scope. Like this -"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main(){\n    let mut s = String::from("Hello");\n    let s1 = &mut s;\n    let s2 = &mut s; // this will error : second mutable borrow occurs here\n}\n')),(0,a.kt)("p",null,"We can make the variable immutable and borrow immutable refernces."),(0,a.kt)("br",null),(0,a.kt)("p",null,"We can not have a mutable refernce if a immutable refernce already exist like this."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main(){\n    let mut s = String::from("Hello");\n    let s1 = & s;\n    let s2 = &mut s; // this will error : cannot borrow `s1` as immutable because it is also borrowed as mutable\n    println!("s1 = {}, s2 = {}",s1,s2);\n}\n')),(0,a.kt)("br",null),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The scope of the refence starts when its first introduced and ends when its last used.")),(0,a.kt)("p",null,"From the above info we can have a hack of declaring mutable refernce when scope of immutable refernce ends."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main(){\n    let mut s = String::from("Hello");\n    let s1 = & s;\n    let s2 = &mut s; // this will error : cannot borrow `s1` as immutable because it is also borrowed as mutable\n    println!("s1 = {}",s1);\n    let s2 = &mut s; // We can declare mutable reference s2 now as the scope of s1 ends at print statement\n}\n')),(0,a.kt)("br",null),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Dangling refernces are the refernces which points to null memory location or location which is allocated to some other program.")),(0,a.kt)("br",null),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main(){\n    let reference_to_nothing = dangle();\n}\nfn dangle() -> &String{ //  this will throw error as scope of s will be finished here we can not make pass it back for that we have to static lifetime.\n    let s = String::from("hello");\n    &s\n}\n')),(0,a.kt)("br",null),(0,a.kt)("br",null),(0,a.kt)("h2",{id:"rules-of-refernces"},"Rules of Refernces"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"At any given time either one mutable reference or any number of immutable refernces."),(0,a.kt)("li",{parentName:"ol"},"Refernces must always be valid.")))}c.isMDXComponent=!0}}]);